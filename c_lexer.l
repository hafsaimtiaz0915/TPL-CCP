%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "c_parser.tab.h" // This will be generated by Bison

// For tracking line numbers
int line_num = 1;
%}

/* States */
%x COMMENT
%x LINE_COMMENT
%x PREPROCESSOR

/* Regular expressions for various token patterns */
DIGIT       [0-9]
LETTER      [a-zA-Z_]
ID          {LETTER}({LETTER}|{DIGIT})*
NUMBER      {DIGIT}+(\.{DIGIT}+)?([eE][+-]?{DIGIT}+)?
WHITESPACE  [ \t\r\f\v]+
STRING      \"([^\"\n]|\\\")*\"
CHAR        \'([^\'\n]|\\.)*\'

%%

"/*"                    { BEGIN(COMMENT); }
<COMMENT>"*/"           { BEGIN(INITIAL); }
<COMMENT>\n             { line_num++; }
<COMMENT>.              { /* ignore other characters in comment */ }

"//"                    { BEGIN(LINE_COMMENT); }
<LINE_COMMENT>\n        { line_num++; BEGIN(INITIAL); }
<LINE_COMMENT>.         { /* ignore other characters in line comment */ }

^"#"                    { BEGIN(PREPROCESSOR); printf("Preprocessor directive at line %d\n", line_num); }
<PREPROCESSOR>\n        { line_num++; BEGIN(INITIAL); }
<PREPROCESSOR>.         { /* ignore characters in preprocessor directive */ }

\n                      { line_num++; }
{WHITESPACE}            { /* ignore whitespace */ }

"auto"      { return AUTO; }
"break"     { return BREAK; }
"case"      { return CASE; }
"char"      { return CHAR; }
"const"     { return CONST; }
"continue"  { return CONTINUE; }
"default"   { return DEFAULT; }
"do"        { return DO; }
"double"    { return DOUBLE; }
"else"      { return ELSE; }
"enum"      { return ENUM; }
"extern"    { return EXTERN; }
"float"     { return FLOAT; }
"for"       { return FOR; }
"goto"      { return GOTO; }
"if"        { return IF; }
"int"       { return INT; }
"long"      { return LONG; }
"register"  { return REGISTER; }
"return"    { return RETURN; }
"short"     { return SHORT; }
"signed"    { return SIGNED; }
"sizeof"    { return SIZEOF; }
"static"    { return STATIC; }
"struct"    { return STRUCT; }
"switch"    { return SWITCH; }
"typedef"   { return TYPEDEF; }
"union"     { return UNION; }
"unsigned"  { return UNSIGNED; }
"void"      { return VOID; }
"volatile"  { return VOLATILE; }
"while"     { return WHILE; }

"+"         { return '+'; }
"-"         { return '-'; }
"*"         { return '*'; }
"/"         { return '/'; }
"%"         { return '%'; }
"="         { return '='; }
"<"         { return '<'; }
">"         { return '>'; }
"!"         { return '!'; }
"&"         { return '&'; }
"|"         { return '|'; }
"^"         { return '^'; }
"~"         { return '~'; }
"?"         { return '?'; }
":"         { return ':'; }
";"         { return ';'; }
","         { return ','; }
"."         { return '.'; }
"("         { return '('; }
")"         { return ')'; }
"["         { return '['; }
"]"         { return ']'; }
"{"         { return '{'; }
"}"         { return '}'; }

"++"        { return INC_OP; }
"--"        { return DEC_OP; }
"=="        { return EQ_OP; }
"!="        { return NE_OP; }
"<="        { return LE_OP; }
">="        { return GE_OP; }
"&&"        { return AND_OP; }
"||"        { return OR_OP; }
"<<"        { return LEFT_OP; }
">>"        { return RIGHT_OP; }
"->"        { return PTR_OP; }
"+="        { return ADD_ASSIGN; }
"-="        { return SUB_ASSIGN; }
"*="        { return MUL_ASSIGN; }
"/="        { return DIV_ASSIGN; }
"%="        { return MOD_ASSIGN; }
"&="        { return AND_ASSIGN; }
"^="        { return XOR_ASSIGN; }
"|="        { return OR_ASSIGN; }
"<<="       { return LEFT_ASSIGN; }
">>="       { return RIGHT_ASSIGN; }

{ID}        { 
              yylval.str_val = strdup(yytext);
              return IDENTIFIER; 
            }

{NUMBER}    { 
              yylval.num_val = atof(yytext);
              return CONSTANT; 
            }

{STRING}    { 
              yylval.str_val = strdup(yytext);
              return STRING_LITERAL; 
            }

{CHAR}      { 
              yylval.str_val = strdup(yytext);
              return CONSTANT; 
            }

.           { printf("Unrecognized character: %s at line %d\n", yytext, line_num); }

%%

int yywrap() {
    return 1;
}